import { SECRET_KEY, EXPIRE_TIME } from "../config/constants";
import { verify, sign } from "jsonwebtoken";
import { factory } from "../config";

import crypto from "crypto";
import { ApiServer } from "aplx-hmw-server";

export class CommonController {
    constructor() {
    }
    /**
 * verify custom jwt token.
 * This token is generated without aws
 * @param x-access-token JWt token
 */
    validateJWTToken(token: string) {
        return new Promise((resolve, reject) => {
            verify(token, SECRET_KEY, (err, decoded) => {
                if (err) {
                    return reject(err);
                }
                resolve(decoded);
            })
        });
    }

    /**
     * validate whether user have access
     * @param param {token: "jwt token", { email: "unique id, in our case, it is email"}
     * @returns boolean
     */
    checkUserRoles(token: string, email: string): Promise<boolean> {
        // Check db, whether user have access to the url.
        return this.validateJWTToken(token).then((success) => {
            return true
        }, (err) => {
            return false;
        })
    }

    /**
     * Check user have authentication to the routes, which is accessed
     * get urls based on the Client
     */
    getPrivilegeOfUserUsingToken(token: string) {
        return new Promise((resolve, reject) => {
            this.validateJWTToken(token).then((success) => {
                const user = success["email"];
                let userModel;
                userModel.findOne({ loginName: user }, 'privileges', (err, success) => {
                    if (err) {
                        ApiServer.Logger.Error(err, __dirname, "getPrivilegeOfUserUsingToken()")
                        return reject(err)
                    }

                    success = JSON.parse(JSON.stringify(success));
                    success = success.privileges;

                    let result = {
                        wildCard: [],
                        individual: []
                    };

                    for (let privilege of success) {
                        if (privilege.includes("*")) {
                            let split = privilege.split("/");
                            const url = split.slice(0, split.length - 1).join("/");
                            result.wildCard.push(url);
                        } else {
                            result.individual.push(privilege);
                        }
                    }
                    return resolve(result);
                })
            }, (err) => {
                reject(err);
            })
        });
    }

    createJWTToken(payload): string {
        // const data = Buffer.from(payload).toString("base64")
        const token = sign(payload, SECRET_KEY, {
            expiresIn: EXPIRE_TIME
        });
        return token;
    }
    

    createHashPassword(data: string): string {
        data += "#j77_6qg2ZKnw$6$w6YYm"
        for (let i = 0; i < 10; i++) {
            data = crypto.createHash('md5').update(data).digest('hex');
        }
        return data;
    }

    comparePassword(rawPassword: string, encryptedPassword: string): Boolean {
        const tempPassword = this.createHashPassword(rawPassword);
        if (tempPassword === encryptedPassword) {
            return true;
        }
        return false;
    }
}
