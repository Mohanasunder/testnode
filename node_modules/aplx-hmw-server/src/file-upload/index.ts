import * as path from "path";
const mv = require("mv");
import * as _ from 'lodash';
import { unlinkSync } from "fs";
// import { Routes } from "../IRoutes";
// import { HttpServer } from "../restify/HttpServer";
// import { Next, Request, Response } from "restify";

export interface imageUploadCallBack {
    /** 
    * will have both image upload success and failed
    */
    onSuccess: (result: {}) => void,
    /**
     * will have any exception
     */
    onFailure?: (error: {}) => void
}

export class FileUpload {
    // implements Routes {
    // initialize(httpServer:HttpServer): void {
    //     httpServer.post('/upload', this.upload.bind(this))
    // }

    // upload(req: Request, res, next) {
    //     this.uploadFiles(req.files).then( (resp) => {
    //         res.send("success")
    //     });
    // }
    /**
     * Function to upload array of files
     * @param array of files
     */
    uploadFiles(files, destination, result, callback: imageUploadCallBack) {
        if (result == undefined) {
            result = {
                errors: [],
                success: []
            };
        }
        var self = this;
        try {
            // make array as flat json
            if (result.success.length === 0 && result.errors.length === 0) {
                files = this.flatJson(files)
            }
            // spilt each file from array
            const file = files[Object.keys(files)[0]];
            delete files[Object.keys(files)[0]];
            destination = destination ? destination : '../../../../uploads';
            const fileName = file.name.replace(".", new Date() + ".").replace(/\s/g, '')
            const destinationPath = path.join(__dirname, destination, fileName);
            mv(file.path, destinationPath, { mkdirp: true }, (err) => {
                if (err) {
                    result.errors.push(err);
                } else {
                    result.success.push(fileName)
                }
                if (_.isEmpty(files)) {
                    return callback.onSuccess(result)
                }
                // unlinkSync(file.path);
                self.uploadFiles(files, destination, result, callback);
            })
        } catch (error) {
            return callback.onFailure(result)
        }
    }

    /**
     * Flat nested json
     */
    flatJson(files) {
        if (files[Object.keys(files)[0]].length > 0) {
            let file = files[Object.keys(files)[0]];
            delete files[Object.keys(files)[0]];
            let totalKey = Object.keys(files).length;
            for (let i = 0; i < file.length; i++) {
                totalKey = totalKey + 1
                files[totalKey + 1] = file[i];
            }
            return files;
        }
        return files;
    }

}